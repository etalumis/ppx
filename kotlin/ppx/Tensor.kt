// automatically generated by the FlatBuffers compiler, do not modify

package ppx

import java.nio.*
import kotlin.math.sign
import com.google.flatbuffers.*

@Suppress("unused")
@ExperimentalUnsignedTypes
class Tensor : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : Tensor {
        __init(_i, _bb)
        return this
    }
    fun data(j: Int) : Double {
        val o = __offset(4)
        return if (o != 0) {
            bb.getDouble(__vector(o) + j * 8)
        } else {
            0.0
        }
    }
    val dataLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    val dataAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 8)
    fun dataInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 8)
    fun shape(j: Int) : Int {
        val o = __offset(6)
        return if (o != 0) {
            bb.getInt(__vector(o) + j * 4)
        } else {
            0
        }
    }
    val shapeLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    val shapeAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 4)
    fun shapeInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 4)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_2_0_0()
        fun getRootAsTensor(_bb: ByteBuffer): Tensor = getRootAsTensor(_bb, Tensor())
        fun getRootAsTensor(_bb: ByteBuffer, obj: Tensor): Tensor {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createTensor(builder: FlatBufferBuilder, dataOffset: Int, shapeOffset: Int) : Int {
            builder.startTable(2)
            addShape(builder, shapeOffset)
            addData(builder, dataOffset)
            return endTensor(builder)
        }
        fun startTensor(builder: FlatBufferBuilder) = builder.startTable(2)
        fun addData(builder: FlatBufferBuilder, data: Int) = builder.addOffset(0, data, 0)
        fun createDataVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }
        fun startDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun addShape(builder: FlatBufferBuilder, shape: Int) = builder.addOffset(1, shape, 0)
        fun createShapeVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addInt(data[i])
            }
            return builder.endVector()
        }
        fun startShapeVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endTensor(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
