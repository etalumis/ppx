// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod ppx {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_BODY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_BODY: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_BODY: [MessageBody; 12] = [
  MessageBody::NONE,
  MessageBody::Handshake,
  MessageBody::HandshakeResult,
  MessageBody::Run,
  MessageBody::RunResult,
  MessageBody::Sample,
  MessageBody::SampleResult,
  MessageBody::Observe,
  MessageBody::ObserveResult,
  MessageBody::Tag,
  MessageBody::TagResult,
  MessageBody::Reset,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageBody(pub u8);
#[allow(non_upper_case_globals)]
impl MessageBody {
  pub const NONE: Self = Self(0);
  pub const Handshake: Self = Self(1);
  pub const HandshakeResult: Self = Self(2);
  pub const Run: Self = Self(3);
  pub const RunResult: Self = Self(4);
  pub const Sample: Self = Self(5);
  pub const SampleResult: Self = Self(6);
  pub const Observe: Self = Self(7);
  pub const ObserveResult: Self = Self(8);
  pub const Tag: Self = Self(9);
  pub const TagResult: Self = Self(10);
  pub const Reset: Self = Self(11);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Handshake,
    Self::HandshakeResult,
    Self::Run,
    Self::RunResult,
    Self::Sample,
    Self::SampleResult,
    Self::Observe,
    Self::ObserveResult,
    Self::Tag,
    Self::TagResult,
    Self::Reset,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Handshake => Some("Handshake"),
      Self::HandshakeResult => Some("HandshakeResult"),
      Self::Run => Some("Run"),
      Self::RunResult => Some("RunResult"),
      Self::Sample => Some("Sample"),
      Self::SampleResult => Some("SampleResult"),
      Self::Observe => Some("Observe"),
      Self::ObserveResult => Some("ObserveResult"),
      Self::Tag => Some("Tag"),
      Self::TagResult => Some("TagResult"),
      Self::Reset => Some("Reset"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for MessageBody {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageBody {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for MessageBody {
    type Output = MessageBody;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for MessageBody {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageBody {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageBody {}
pub struct MessageBodyUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DISTRIBUTION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DISTRIBUTION: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DISTRIBUTION: [Distribution; 12] = [
  Distribution::NONE,
  Distribution::Normal,
  Distribution::Uniform,
  Distribution::Categorical,
  Distribution::Poisson,
  Distribution::Bernoulli,
  Distribution::Beta,
  Distribution::Exponential,
  Distribution::Gamma,
  Distribution::LogNormal,
  Distribution::Binomial,
  Distribution::Weibull,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Distribution(pub u8);
#[allow(non_upper_case_globals)]
impl Distribution {
  pub const NONE: Self = Self(0);
  pub const Normal: Self = Self(1);
  pub const Uniform: Self = Self(2);
  pub const Categorical: Self = Self(3);
  pub const Poisson: Self = Self(4);
  pub const Bernoulli: Self = Self(5);
  pub const Beta: Self = Self(6);
  pub const Exponential: Self = Self(7);
  pub const Gamma: Self = Self(8);
  pub const LogNormal: Self = Self(9);
  pub const Binomial: Self = Self(10);
  pub const Weibull: Self = Self(11);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Normal,
    Self::Uniform,
    Self::Categorical,
    Self::Poisson,
    Self::Bernoulli,
    Self::Beta,
    Self::Exponential,
    Self::Gamma,
    Self::LogNormal,
    Self::Binomial,
    Self::Weibull,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Normal => Some("Normal"),
      Self::Uniform => Some("Uniform"),
      Self::Categorical => Some("Categorical"),
      Self::Poisson => Some("Poisson"),
      Self::Bernoulli => Some("Bernoulli"),
      Self::Beta => Some("Beta"),
      Self::Exponential => Some("Exponential"),
      Self::Gamma => Some("Gamma"),
      Self::LogNormal => Some("LogNormal"),
      Self::Binomial => Some("Binomial"),
      Self::Weibull => Some("Weibull"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for Distribution {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Distribution {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Distribution {
    type Output = Distribution;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Distribution {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Distribution {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Distribution {}
pub struct DistributionUnionTableOffset {}

pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
    type Inner = Message<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Message<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Message { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MessageArgs) -> flatbuffers::WIPOffset<Message<'bldr>> {
      let mut builder = MessageBuilder::new(_fbb);
      if let Some(x) = args.body { builder.add_body(x); }
      builder.add_body_type(args.body_type);
      builder.finish()
    }

    pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_BODY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn body_type(&self) -> MessageBody {
    self._tab.get::<MessageBody>(Message::VT_BODY_TYPE, Some(MessageBody::NONE)).unwrap()
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_BODY, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_handshake(&self) -> Option<Handshake<'a>> {
    if self.body_type() == MessageBody::Handshake {
      self.body().map(Handshake::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_handshake_result(&self) -> Option<HandshakeResult<'a>> {
    if self.body_type() == MessageBody::HandshakeResult {
      self.body().map(HandshakeResult::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_run(&self) -> Option<Run<'a>> {
    if self.body_type() == MessageBody::Run {
      self.body().map(Run::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_run_result(&self) -> Option<RunResult<'a>> {
    if self.body_type() == MessageBody::RunResult {
      self.body().map(RunResult::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_sample(&self) -> Option<Sample<'a>> {
    if self.body_type() == MessageBody::Sample {
      self.body().map(Sample::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_sample_result(&self) -> Option<SampleResult<'a>> {
    if self.body_type() == MessageBody::SampleResult {
      self.body().map(SampleResult::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_observe(&self) -> Option<Observe<'a>> {
    if self.body_type() == MessageBody::Observe {
      self.body().map(Observe::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_observe_result(&self) -> Option<ObserveResult<'a>> {
    if self.body_type() == MessageBody::ObserveResult {
      self.body().map(ObserveResult::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_tag(&self) -> Option<Tag<'a>> {
    if self.body_type() == MessageBody::Tag {
      self.body().map(Tag::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_tag_result(&self) -> Option<TagResult<'a>> {
    if self.body_type() == MessageBody::TagResult {
      self.body().map(TagResult::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_reset(&self) -> Option<Reset<'a>> {
    if self.body_type() == MessageBody::Reset {
      self.body().map(Reset::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<MessageBody, _>(&"body_type", Self::VT_BODY_TYPE, &"body", Self::VT_BODY, false, |key, v, pos| {
        match key {
          MessageBody::Handshake => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Handshake>>("MessageBody::Handshake", pos),
          MessageBody::HandshakeResult => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HandshakeResult>>("MessageBody::HandshakeResult", pos),
          MessageBody::Run => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Run>>("MessageBody::Run", pos),
          MessageBody::RunResult => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunResult>>("MessageBody::RunResult", pos),
          MessageBody::Sample => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Sample>>("MessageBody::Sample", pos),
          MessageBody::SampleResult => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SampleResult>>("MessageBody::SampleResult", pos),
          MessageBody::Observe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Observe>>("MessageBody::Observe", pos),
          MessageBody::ObserveResult => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ObserveResult>>("MessageBody::ObserveResult", pos),
          MessageBody::Tag => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Tag>>("MessageBody::Tag", pos),
          MessageBody::TagResult => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TagResult>>("MessageBody::TagResult", pos),
          MessageBody::Reset => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Reset>>("MessageBody::Reset", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs {
    pub body_type: MessageBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
    #[inline]
    fn default() -> Self {
        MessageArgs {
            body_type: MessageBody::NONE,
            body: None,
        }
    }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_body_type(&mut self, body_type: MessageBody) {
    self.fbb_.push_slot::<MessageBody>(Message::VT_BODY_TYPE, body_type, MessageBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("body_type", &self.body_type());
      match self.body_type() {
        MessageBody::Handshake => {
          if let Some(x) = self.body_as_handshake() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::HandshakeResult => {
          if let Some(x) = self.body_as_handshake_result() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::Run => {
          if let Some(x) = self.body_as_run() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::RunResult => {
          if let Some(x) = self.body_as_run_result() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::Sample => {
          if let Some(x) = self.body_as_sample() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::SampleResult => {
          if let Some(x) = self.body_as_sample_result() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::Observe => {
          if let Some(x) = self.body_as_observe() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::ObserveResult => {
          if let Some(x) = self.body_as_observe_result() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::Tag => {
          if let Some(x) = self.body_as_tag() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::TagResult => {
          if let Some(x) = self.body_as_tag_result() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::Reset => {
          if let Some(x) = self.body_as_reset() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("body", &x)
        },
      };
      ds.finish()
  }
}
pub enum TensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
    type Inner = Tensor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Tensor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Tensor { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TensorArgs<'args>) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
      let mut builder = TensorBuilder::new(_fbb);
      if let Some(x) = args.shape { builder.add_shape(x); }
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_SHAPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(Tensor::VT_DATA, None)
  }
  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Tensor::VT_SHAPE, None)
  }
}

impl flatbuffers::Verifiable for Tensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(&"data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(&"shape", Self::VT_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for TensorArgs<'a> {
    #[inline]
    fn default() -> Self {
        TensorArgs {
            data: None,
            shape: None,
        }
    }
}
pub struct TensorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_DATA, data);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Tensor<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Tensor");
      ds.field("data", &self.data());
      ds.field("shape", &self.shape());
      ds.finish()
  }
}
pub enum HandshakeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Handshake<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Handshake<'a> {
    type Inner = Handshake<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Handshake<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Handshake { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HandshakeArgs<'args>) -> flatbuffers::WIPOffset<Handshake<'bldr>> {
      let mut builder = HandshakeBuilder::new(_fbb);
      if let Some(x) = args.system_name { builder.add_system_name(x); }
      builder.finish()
    }

    pub const VT_SYSTEM_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn system_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Handshake::VT_SYSTEM_NAME, None)
  }
}

impl flatbuffers::Verifiable for Handshake<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"system_name", Self::VT_SYSTEM_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct HandshakeArgs<'a> {
    pub system_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HandshakeArgs<'a> {
    #[inline]
    fn default() -> Self {
        HandshakeArgs {
            system_name: None,
        }
    }
}
pub struct HandshakeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HandshakeBuilder<'a, 'b> {
  #[inline]
  pub fn add_system_name(&mut self, system_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Handshake::VT_SYSTEM_NAME, system_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HandshakeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HandshakeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Handshake<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Handshake<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Handshake");
      ds.field("system_name", &self.system_name());
      ds.finish()
  }
}
pub enum HandshakeResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HandshakeResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HandshakeResult<'a> {
    type Inner = HandshakeResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> HandshakeResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        HandshakeResult { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HandshakeResultArgs<'args>) -> flatbuffers::WIPOffset<HandshakeResult<'bldr>> {
      let mut builder = HandshakeResultBuilder::new(_fbb);
      if let Some(x) = args.model_name { builder.add_model_name(x); }
      if let Some(x) = args.system_name { builder.add_system_name(x); }
      builder.finish()
    }

    pub const VT_SYSTEM_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_MODEL_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn system_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HandshakeResult::VT_SYSTEM_NAME, None)
  }
  #[inline]
  pub fn model_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HandshakeResult::VT_MODEL_NAME, None)
  }
}

impl flatbuffers::Verifiable for HandshakeResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"system_name", Self::VT_SYSTEM_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"model_name", Self::VT_MODEL_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct HandshakeResultArgs<'a> {
    pub system_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub model_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HandshakeResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        HandshakeResultArgs {
            system_name: None,
            model_name: None,
        }
    }
}
pub struct HandshakeResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HandshakeResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_system_name(&mut self, system_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HandshakeResult::VT_SYSTEM_NAME, system_name);
  }
  #[inline]
  pub fn add_model_name(&mut self, model_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HandshakeResult::VT_MODEL_NAME, model_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HandshakeResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HandshakeResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HandshakeResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for HandshakeResult<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("HandshakeResult");
      ds.field("system_name", &self.system_name());
      ds.field("model_name", &self.model_name());
      ds.finish()
  }
}
pub enum RunOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Run<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Run<'a> {
    type Inner = Run<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Run<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Run { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args RunArgs) -> flatbuffers::WIPOffset<Run<'bldr>> {
      let mut builder = RunBuilder::new(_fbb);
      builder.finish()
    }

}

impl flatbuffers::Verifiable for Run<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RunArgs {
}
impl<'a> Default for RunArgs {
    #[inline]
    fn default() -> Self {
        RunArgs {
        }
    }
}
pub struct RunBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RunBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Run<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Run<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Run");
      ds.finish()
  }
}
pub enum RunResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RunResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunResult<'a> {
    type Inner = RunResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> RunResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RunResult { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RunResultArgs<'args>) -> flatbuffers::WIPOffset<RunResult<'bldr>> {
      let mut builder = RunResultBuilder::new(_fbb);
      if let Some(x) = args.result { builder.add_result(x); }
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn result(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(RunResult::VT_RESULT, None)
  }
}

impl flatbuffers::Verifiable for RunResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"result", Self::VT_RESULT, false)?
     .finish();
    Ok(())
  }
}
pub struct RunResultArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for RunResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        RunResultArgs {
            result: None,
        }
    }
}
pub struct RunResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(RunResult::VT_RESULT, result);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RunResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RunResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RunResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RunResult<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RunResult");
      ds.field("result", &self.result());
      ds.finish()
  }
}
pub enum SampleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Sample<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sample<'a> {
    type Inner = Sample<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Sample<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Sample { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SampleArgs<'args>) -> flatbuffers::WIPOffset<Sample<'bldr>> {
      let mut builder = SampleBuilder::new(_fbb);
      if let Some(x) = args.distribution { builder.add_distribution(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.address { builder.add_address(x); }
      builder.add_control(args.control);
      builder.add_distribution_type(args.distribution_type);
      builder.finish()
    }

    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DISTRIBUTION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DISTRIBUTION: flatbuffers::VOffsetT = 10;
    pub const VT_CONTROL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sample::VT_ADDRESS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sample::VT_NAME, None)
  }
  #[inline]
  pub fn distribution_type(&self) -> Distribution {
    self._tab.get::<Distribution>(Sample::VT_DISTRIBUTION_TYPE, Some(Distribution::NONE)).unwrap()
  }
  #[inline]
  pub fn distribution(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Sample::VT_DISTRIBUTION, None)
  }
  #[inline]
  pub fn control(&self) -> bool {
    self._tab.get::<bool>(Sample::VT_CONTROL, Some(true)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_normal(&self) -> Option<Normal<'a>> {
    if self.distribution_type() == Distribution::Normal {
      self.distribution().map(Normal::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_uniform(&self) -> Option<Uniform<'a>> {
    if self.distribution_type() == Distribution::Uniform {
      self.distribution().map(Uniform::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_categorical(&self) -> Option<Categorical<'a>> {
    if self.distribution_type() == Distribution::Categorical {
      self.distribution().map(Categorical::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_poisson(&self) -> Option<Poisson<'a>> {
    if self.distribution_type() == Distribution::Poisson {
      self.distribution().map(Poisson::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_bernoulli(&self) -> Option<Bernoulli<'a>> {
    if self.distribution_type() == Distribution::Bernoulli {
      self.distribution().map(Bernoulli::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_beta(&self) -> Option<Beta<'a>> {
    if self.distribution_type() == Distribution::Beta {
      self.distribution().map(Beta::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_exponential(&self) -> Option<Exponential<'a>> {
    if self.distribution_type() == Distribution::Exponential {
      self.distribution().map(Exponential::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_gamma(&self) -> Option<Gamma<'a>> {
    if self.distribution_type() == Distribution::Gamma {
      self.distribution().map(Gamma::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_log_normal(&self) -> Option<LogNormal<'a>> {
    if self.distribution_type() == Distribution::LogNormal {
      self.distribution().map(LogNormal::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_binomial(&self) -> Option<Binomial<'a>> {
    if self.distribution_type() == Distribution::Binomial {
      self.distribution().map(Binomial::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_weibull(&self) -> Option<Weibull<'a>> {
    if self.distribution_type() == Distribution::Weibull {
      self.distribution().map(Weibull::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Sample<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"address", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_union::<Distribution, _>(&"distribution_type", Self::VT_DISTRIBUTION_TYPE, &"distribution", Self::VT_DISTRIBUTION, false, |key, v, pos| {
        match key {
          Distribution::Normal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Normal>>("Distribution::Normal", pos),
          Distribution::Uniform => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Uniform>>("Distribution::Uniform", pos),
          Distribution::Categorical => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Categorical>>("Distribution::Categorical", pos),
          Distribution::Poisson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Poisson>>("Distribution::Poisson", pos),
          Distribution::Bernoulli => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Bernoulli>>("Distribution::Bernoulli", pos),
          Distribution::Beta => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Beta>>("Distribution::Beta", pos),
          Distribution::Exponential => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Exponential>>("Distribution::Exponential", pos),
          Distribution::Gamma => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Gamma>>("Distribution::Gamma", pos),
          Distribution::LogNormal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogNormal>>("Distribution::LogNormal", pos),
          Distribution::Binomial => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Binomial>>("Distribution::Binomial", pos),
          Distribution::Weibull => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Weibull>>("Distribution::Weibull", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<bool>(&"control", Self::VT_CONTROL, false)?
     .finish();
    Ok(())
  }
}
pub struct SampleArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub distribution_type: Distribution,
    pub distribution: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub control: bool,
}
impl<'a> Default for SampleArgs<'a> {
    #[inline]
    fn default() -> Self {
        SampleArgs {
            address: None,
            name: None,
            distribution_type: Distribution::NONE,
            distribution: None,
            control: true,
        }
    }
}
pub struct SampleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SampleBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sample::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sample::VT_NAME, name);
  }
  #[inline]
  pub fn add_distribution_type(&mut self, distribution_type: Distribution) {
    self.fbb_.push_slot::<Distribution>(Sample::VT_DISTRIBUTION_TYPE, distribution_type, Distribution::NONE);
  }
  #[inline]
  pub fn add_distribution(&mut self, distribution: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sample::VT_DISTRIBUTION, distribution);
  }
  #[inline]
  pub fn add_control(&mut self, control: bool) {
    self.fbb_.push_slot::<bool>(Sample::VT_CONTROL, control, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SampleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SampleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sample<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Sample<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Sample");
      ds.field("address", &self.address());
      ds.field("name", &self.name());
      ds.field("distribution_type", &self.distribution_type());
      match self.distribution_type() {
        Distribution::Normal => {
          if let Some(x) = self.distribution_as_normal() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Uniform => {
          if let Some(x) = self.distribution_as_uniform() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Categorical => {
          if let Some(x) = self.distribution_as_categorical() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Poisson => {
          if let Some(x) = self.distribution_as_poisson() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Bernoulli => {
          if let Some(x) = self.distribution_as_bernoulli() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Beta => {
          if let Some(x) = self.distribution_as_beta() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Exponential => {
          if let Some(x) = self.distribution_as_exponential() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Gamma => {
          if let Some(x) = self.distribution_as_gamma() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::LogNormal => {
          if let Some(x) = self.distribution_as_log_normal() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Binomial => {
          if let Some(x) = self.distribution_as_binomial() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Weibull => {
          if let Some(x) = self.distribution_as_weibull() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("distribution", &x)
        },
      };
      ds.field("control", &self.control());
      ds.finish()
  }
}
pub enum SampleResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SampleResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SampleResult<'a> {
    type Inner = SampleResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> SampleResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SampleResult { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SampleResultArgs<'args>) -> flatbuffers::WIPOffset<SampleResult<'bldr>> {
      let mut builder = SampleResultBuilder::new(_fbb);
      if let Some(x) = args.result { builder.add_result(x); }
      builder.finish()
    }

    pub const VT_RESULT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn result(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(SampleResult::VT_RESULT, None)
  }
}

impl flatbuffers::Verifiable for SampleResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"result", Self::VT_RESULT, false)?
     .finish();
    Ok(())
  }
}
pub struct SampleResultArgs<'a> {
    pub result: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for SampleResultArgs<'a> {
    #[inline]
    fn default() -> Self {
        SampleResultArgs {
            result: None,
        }
    }
}
pub struct SampleResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SampleResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_result(&mut self, result: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(SampleResult::VT_RESULT, result);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SampleResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SampleResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SampleResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for SampleResult<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("SampleResult");
      ds.field("result", &self.result());
      ds.finish()
  }
}
pub enum ObserveOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Observe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Observe<'a> {
    type Inner = Observe<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Observe<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Observe { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ObserveArgs<'args>) -> flatbuffers::WIPOffset<Observe<'bldr>> {
      let mut builder = ObserveBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.distribution { builder.add_distribution(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.address { builder.add_address(x); }
      builder.add_distribution_type(args.distribution_type);
      builder.finish()
    }

    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DISTRIBUTION_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DISTRIBUTION: flatbuffers::VOffsetT = 10;
    pub const VT_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Observe::VT_ADDRESS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Observe::VT_NAME, None)
  }
  #[inline]
  pub fn distribution_type(&self) -> Distribution {
    self._tab.get::<Distribution>(Observe::VT_DISTRIBUTION_TYPE, Some(Distribution::NONE)).unwrap()
  }
  #[inline]
  pub fn distribution(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Observe::VT_DISTRIBUTION, None)
  }
  #[inline]
  pub fn value(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Observe::VT_VALUE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_normal(&self) -> Option<Normal<'a>> {
    if self.distribution_type() == Distribution::Normal {
      self.distribution().map(Normal::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_uniform(&self) -> Option<Uniform<'a>> {
    if self.distribution_type() == Distribution::Uniform {
      self.distribution().map(Uniform::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_categorical(&self) -> Option<Categorical<'a>> {
    if self.distribution_type() == Distribution::Categorical {
      self.distribution().map(Categorical::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_poisson(&self) -> Option<Poisson<'a>> {
    if self.distribution_type() == Distribution::Poisson {
      self.distribution().map(Poisson::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_bernoulli(&self) -> Option<Bernoulli<'a>> {
    if self.distribution_type() == Distribution::Bernoulli {
      self.distribution().map(Bernoulli::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_beta(&self) -> Option<Beta<'a>> {
    if self.distribution_type() == Distribution::Beta {
      self.distribution().map(Beta::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_exponential(&self) -> Option<Exponential<'a>> {
    if self.distribution_type() == Distribution::Exponential {
      self.distribution().map(Exponential::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_gamma(&self) -> Option<Gamma<'a>> {
    if self.distribution_type() == Distribution::Gamma {
      self.distribution().map(Gamma::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_log_normal(&self) -> Option<LogNormal<'a>> {
    if self.distribution_type() == Distribution::LogNormal {
      self.distribution().map(LogNormal::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_binomial(&self) -> Option<Binomial<'a>> {
    if self.distribution_type() == Distribution::Binomial {
      self.distribution().map(Binomial::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn distribution_as_weibull(&self) -> Option<Weibull<'a>> {
    if self.distribution_type() == Distribution::Weibull {
      self.distribution().map(Weibull::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Observe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"address", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_union::<Distribution, _>(&"distribution_type", Self::VT_DISTRIBUTION_TYPE, &"distribution", Self::VT_DISTRIBUTION, false, |key, v, pos| {
        match key {
          Distribution::Normal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Normal>>("Distribution::Normal", pos),
          Distribution::Uniform => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Uniform>>("Distribution::Uniform", pos),
          Distribution::Categorical => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Categorical>>("Distribution::Categorical", pos),
          Distribution::Poisson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Poisson>>("Distribution::Poisson", pos),
          Distribution::Bernoulli => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Bernoulli>>("Distribution::Bernoulli", pos),
          Distribution::Beta => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Beta>>("Distribution::Beta", pos),
          Distribution::Exponential => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Exponential>>("Distribution::Exponential", pos),
          Distribution::Gamma => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Gamma>>("Distribution::Gamma", pos),
          Distribution::LogNormal => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogNormal>>("Distribution::LogNormal", pos),
          Distribution::Binomial => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Binomial>>("Distribution::Binomial", pos),
          Distribution::Weibull => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Weibull>>("Distribution::Weibull", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ObserveArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub distribution_type: Distribution,
    pub distribution: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub value: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for ObserveArgs<'a> {
    #[inline]
    fn default() -> Self {
        ObserveArgs {
            address: None,
            name: None,
            distribution_type: Distribution::NONE,
            distribution: None,
            value: None,
        }
    }
}
pub struct ObserveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ObserveBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Observe::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Observe::VT_NAME, name);
  }
  #[inline]
  pub fn add_distribution_type(&mut self, distribution_type: Distribution) {
    self.fbb_.push_slot::<Distribution>(Observe::VT_DISTRIBUTION_TYPE, distribution_type, Distribution::NONE);
  }
  #[inline]
  pub fn add_distribution(&mut self, distribution: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Observe::VT_DISTRIBUTION, distribution);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Observe::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObserveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ObserveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Observe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Observe<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Observe");
      ds.field("address", &self.address());
      ds.field("name", &self.name());
      ds.field("distribution_type", &self.distribution_type());
      match self.distribution_type() {
        Distribution::Normal => {
          if let Some(x) = self.distribution_as_normal() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Uniform => {
          if let Some(x) = self.distribution_as_uniform() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Categorical => {
          if let Some(x) = self.distribution_as_categorical() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Poisson => {
          if let Some(x) = self.distribution_as_poisson() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Bernoulli => {
          if let Some(x) = self.distribution_as_bernoulli() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Beta => {
          if let Some(x) = self.distribution_as_beta() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Exponential => {
          if let Some(x) = self.distribution_as_exponential() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Gamma => {
          if let Some(x) = self.distribution_as_gamma() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::LogNormal => {
          if let Some(x) = self.distribution_as_log_normal() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Binomial => {
          if let Some(x) = self.distribution_as_binomial() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Distribution::Weibull => {
          if let Some(x) = self.distribution_as_weibull() {
            ds.field("distribution", &x)
          } else {
            ds.field("distribution", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("distribution", &x)
        },
      };
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ObserveResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ObserveResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ObserveResult<'a> {
    type Inner = ObserveResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> ObserveResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ObserveResult { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ObserveResultArgs) -> flatbuffers::WIPOffset<ObserveResult<'bldr>> {
      let mut builder = ObserveResultBuilder::new(_fbb);
      builder.finish()
    }

}

impl flatbuffers::Verifiable for ObserveResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ObserveResultArgs {
}
impl<'a> Default for ObserveResultArgs {
    #[inline]
    fn default() -> Self {
        ObserveResultArgs {
        }
    }
}
pub struct ObserveResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ObserveResultBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObserveResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ObserveResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ObserveResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ObserveResult<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ObserveResult");
      ds.finish()
  }
}
pub enum TagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
    type Inner = Tag<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Tag<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Tag { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TagArgs<'args>) -> flatbuffers::WIPOffset<Tag<'bldr>> {
      let mut builder = TagBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.address { builder.add_address(x); }
      builder.finish()
    }

    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_ADDRESS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_NAME, None)
  }
  #[inline]
  pub fn value(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Tag::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Tag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"address", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct TagArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for TagArgs<'a> {
    #[inline]
    fn default() -> Self {
        TagArgs {
            address: None,
            name: None,
            value: None,
        }
    }
}
pub struct TagBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TagBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Tag::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Tag<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Tag");
      ds.field("address", &self.address());
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum TagResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TagResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TagResult<'a> {
    type Inner = TagResult<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> TagResult<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TagResult { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args TagResultArgs) -> flatbuffers::WIPOffset<TagResult<'bldr>> {
      let mut builder = TagResultBuilder::new(_fbb);
      builder.finish()
    }

}

impl flatbuffers::Verifiable for TagResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TagResultArgs {
}
impl<'a> Default for TagResultArgs {
    #[inline]
    fn default() -> Self {
        TagResultArgs {
        }
    }
}
pub struct TagResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TagResultBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TagResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TagResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TagResult<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TagResult");
      ds.finish()
  }
}
pub enum ResetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Reset<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Reset<'a> {
    type Inner = Reset<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Reset<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Reset { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ResetArgs) -> flatbuffers::WIPOffset<Reset<'bldr>> {
      let mut builder = ResetBuilder::new(_fbb);
      builder.finish()
    }

}

impl flatbuffers::Verifiable for Reset<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ResetArgs {
}
impl<'a> Default for ResetArgs {
    #[inline]
    fn default() -> Self {
        ResetArgs {
        }
    }
}
pub struct ResetBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResetBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResetBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Reset<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Reset<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Reset");
      ds.finish()
  }
}
pub enum NormalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Normal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Normal<'a> {
    type Inner = Normal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Normal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Normal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NormalArgs<'args>) -> flatbuffers::WIPOffset<Normal<'bldr>> {
      let mut builder = NormalBuilder::new(_fbb);
      if let Some(x) = args.stddev { builder.add_stddev(x); }
      if let Some(x) = args.mean { builder.add_mean(x); }
      builder.finish()
    }

    pub const VT_MEAN: flatbuffers::VOffsetT = 4;
    pub const VT_STDDEV: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn mean(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Normal::VT_MEAN, None)
  }
  #[inline]
  pub fn stddev(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Normal::VT_STDDEV, None)
  }
}

impl flatbuffers::Verifiable for Normal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"mean", Self::VT_MEAN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"stddev", Self::VT_STDDEV, false)?
     .finish();
    Ok(())
  }
}
pub struct NormalArgs<'a> {
    pub mean: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub stddev: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for NormalArgs<'a> {
    #[inline]
    fn default() -> Self {
        NormalArgs {
            mean: None,
            stddev: None,
        }
    }
}
pub struct NormalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NormalBuilder<'a, 'b> {
  #[inline]
  pub fn add_mean(&mut self, mean: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Normal::VT_MEAN, mean);
  }
  #[inline]
  pub fn add_stddev(&mut self, stddev: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Normal::VT_STDDEV, stddev);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NormalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NormalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Normal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Normal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Normal");
      ds.field("mean", &self.mean());
      ds.field("stddev", &self.stddev());
      ds.finish()
  }
}
pub enum UniformOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Uniform<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Uniform<'a> {
    type Inner = Uniform<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Uniform<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Uniform { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UniformArgs<'args>) -> flatbuffers::WIPOffset<Uniform<'bldr>> {
      let mut builder = UniformBuilder::new(_fbb);
      if let Some(x) = args.high { builder.add_high(x); }
      if let Some(x) = args.low { builder.add_low(x); }
      builder.finish()
    }

    pub const VT_LOW: flatbuffers::VOffsetT = 4;
    pub const VT_HIGH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn low(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Uniform::VT_LOW, None)
  }
  #[inline]
  pub fn high(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Uniform::VT_HIGH, None)
  }
}

impl flatbuffers::Verifiable for Uniform<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"low", Self::VT_LOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"high", Self::VT_HIGH, false)?
     .finish();
    Ok(())
  }
}
pub struct UniformArgs<'a> {
    pub low: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub high: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for UniformArgs<'a> {
    #[inline]
    fn default() -> Self {
        UniformArgs {
            low: None,
            high: None,
        }
    }
}
pub struct UniformBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UniformBuilder<'a, 'b> {
  #[inline]
  pub fn add_low(&mut self, low: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Uniform::VT_LOW, low);
  }
  #[inline]
  pub fn add_high(&mut self, high: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Uniform::VT_HIGH, high);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UniformBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UniformBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Uniform<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Uniform<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Uniform");
      ds.field("low", &self.low());
      ds.field("high", &self.high());
      ds.finish()
  }
}
pub enum CategoricalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Categorical<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Categorical<'a> {
    type Inner = Categorical<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Categorical<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Categorical { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CategoricalArgs<'args>) -> flatbuffers::WIPOffset<Categorical<'bldr>> {
      let mut builder = CategoricalBuilder::new(_fbb);
      if let Some(x) = args.probs { builder.add_probs(x); }
      builder.finish()
    }

    pub const VT_PROBS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn probs(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Categorical::VT_PROBS, None)
  }
}

impl flatbuffers::Verifiable for Categorical<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"probs", Self::VT_PROBS, false)?
     .finish();
    Ok(())
  }
}
pub struct CategoricalArgs<'a> {
    pub probs: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for CategoricalArgs<'a> {
    #[inline]
    fn default() -> Self {
        CategoricalArgs {
            probs: None,
        }
    }
}
pub struct CategoricalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CategoricalBuilder<'a, 'b> {
  #[inline]
  pub fn add_probs(&mut self, probs: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Categorical::VT_PROBS, probs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CategoricalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CategoricalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Categorical<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Categorical<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Categorical");
      ds.field("probs", &self.probs());
      ds.finish()
  }
}
pub enum PoissonOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Poisson<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Poisson<'a> {
    type Inner = Poisson<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Poisson<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Poisson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PoissonArgs<'args>) -> flatbuffers::WIPOffset<Poisson<'bldr>> {
      let mut builder = PoissonBuilder::new(_fbb);
      if let Some(x) = args.rate { builder.add_rate(x); }
      builder.finish()
    }

    pub const VT_RATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rate(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Poisson::VT_RATE, None)
  }
}

impl flatbuffers::Verifiable for Poisson<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"rate", Self::VT_RATE, false)?
     .finish();
    Ok(())
  }
}
pub struct PoissonArgs<'a> {
    pub rate: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for PoissonArgs<'a> {
    #[inline]
    fn default() -> Self {
        PoissonArgs {
            rate: None,
        }
    }
}
pub struct PoissonBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PoissonBuilder<'a, 'b> {
  #[inline]
  pub fn add_rate(&mut self, rate: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Poisson::VT_RATE, rate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PoissonBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PoissonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Poisson<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Poisson<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Poisson");
      ds.field("rate", &self.rate());
      ds.finish()
  }
}
pub enum BernoulliOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bernoulli<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bernoulli<'a> {
    type Inner = Bernoulli<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Bernoulli<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bernoulli { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BernoulliArgs<'args>) -> flatbuffers::WIPOffset<Bernoulli<'bldr>> {
      let mut builder = BernoulliBuilder::new(_fbb);
      if let Some(x) = args.probs { builder.add_probs(x); }
      builder.finish()
    }

    pub const VT_PROBS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn probs(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Bernoulli::VT_PROBS, None)
  }
}

impl flatbuffers::Verifiable for Bernoulli<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"probs", Self::VT_PROBS, false)?
     .finish();
    Ok(())
  }
}
pub struct BernoulliArgs<'a> {
    pub probs: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for BernoulliArgs<'a> {
    #[inline]
    fn default() -> Self {
        BernoulliArgs {
            probs: None,
        }
    }
}
pub struct BernoulliBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BernoulliBuilder<'a, 'b> {
  #[inline]
  pub fn add_probs(&mut self, probs: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Bernoulli::VT_PROBS, probs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BernoulliBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BernoulliBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bernoulli<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Bernoulli<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Bernoulli");
      ds.field("probs", &self.probs());
      ds.finish()
  }
}
pub enum BetaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Beta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Beta<'a> {
    type Inner = Beta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Beta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Beta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BetaArgs<'args>) -> flatbuffers::WIPOffset<Beta<'bldr>> {
      let mut builder = BetaBuilder::new(_fbb);
      if let Some(x) = args.concentration0 { builder.add_concentration0(x); }
      if let Some(x) = args.concentration1 { builder.add_concentration1(x); }
      builder.finish()
    }

    pub const VT_CONCENTRATION1: flatbuffers::VOffsetT = 4;
    pub const VT_CONCENTRATION0: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn concentration1(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Beta::VT_CONCENTRATION1, None)
  }
  #[inline]
  pub fn concentration0(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Beta::VT_CONCENTRATION0, None)
  }
}

impl flatbuffers::Verifiable for Beta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"concentration1", Self::VT_CONCENTRATION1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"concentration0", Self::VT_CONCENTRATION0, false)?
     .finish();
    Ok(())
  }
}
pub struct BetaArgs<'a> {
    pub concentration1: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub concentration0: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for BetaArgs<'a> {
    #[inline]
    fn default() -> Self {
        BetaArgs {
            concentration1: None,
            concentration0: None,
        }
    }
}
pub struct BetaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BetaBuilder<'a, 'b> {
  #[inline]
  pub fn add_concentration1(&mut self, concentration1: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Beta::VT_CONCENTRATION1, concentration1);
  }
  #[inline]
  pub fn add_concentration0(&mut self, concentration0: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Beta::VT_CONCENTRATION0, concentration0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BetaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Beta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Beta<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Beta");
      ds.field("concentration1", &self.concentration1());
      ds.field("concentration0", &self.concentration0());
      ds.finish()
  }
}
pub enum ExponentialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Exponential<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Exponential<'a> {
    type Inner = Exponential<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Exponential<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Exponential { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExponentialArgs<'args>) -> flatbuffers::WIPOffset<Exponential<'bldr>> {
      let mut builder = ExponentialBuilder::new(_fbb);
      if let Some(x) = args.rate { builder.add_rate(x); }
      builder.finish()
    }

    pub const VT_RATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn rate(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Exponential::VT_RATE, None)
  }
}

impl flatbuffers::Verifiable for Exponential<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"rate", Self::VT_RATE, false)?
     .finish();
    Ok(())
  }
}
pub struct ExponentialArgs<'a> {
    pub rate: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for ExponentialArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExponentialArgs {
            rate: None,
        }
    }
}
pub struct ExponentialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExponentialBuilder<'a, 'b> {
  #[inline]
  pub fn add_rate(&mut self, rate: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Exponential::VT_RATE, rate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExponentialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExponentialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Exponential<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Exponential<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Exponential");
      ds.field("rate", &self.rate());
      ds.finish()
  }
}
pub enum GammaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Gamma<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gamma<'a> {
    type Inner = Gamma<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Gamma<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Gamma { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GammaArgs<'args>) -> flatbuffers::WIPOffset<Gamma<'bldr>> {
      let mut builder = GammaBuilder::new(_fbb);
      if let Some(x) = args.rate { builder.add_rate(x); }
      if let Some(x) = args.concentration { builder.add_concentration(x); }
      builder.finish()
    }

    pub const VT_CONCENTRATION: flatbuffers::VOffsetT = 4;
    pub const VT_RATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn concentration(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Gamma::VT_CONCENTRATION, None)
  }
  #[inline]
  pub fn rate(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Gamma::VT_RATE, None)
  }
}

impl flatbuffers::Verifiable for Gamma<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"concentration", Self::VT_CONCENTRATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"rate", Self::VT_RATE, false)?
     .finish();
    Ok(())
  }
}
pub struct GammaArgs<'a> {
    pub concentration: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub rate: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for GammaArgs<'a> {
    #[inline]
    fn default() -> Self {
        GammaArgs {
            concentration: None,
            rate: None,
        }
    }
}
pub struct GammaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GammaBuilder<'a, 'b> {
  #[inline]
  pub fn add_concentration(&mut self, concentration: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Gamma::VT_CONCENTRATION, concentration);
  }
  #[inline]
  pub fn add_rate(&mut self, rate: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Gamma::VT_RATE, rate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GammaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GammaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gamma<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Gamma<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Gamma");
      ds.field("concentration", &self.concentration());
      ds.field("rate", &self.rate());
      ds.finish()
  }
}
pub enum LogNormalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogNormal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogNormal<'a> {
    type Inner = LogNormal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> LogNormal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LogNormal { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LogNormalArgs<'args>) -> flatbuffers::WIPOffset<LogNormal<'bldr>> {
      let mut builder = LogNormalBuilder::new(_fbb);
      if let Some(x) = args.scale { builder.add_scale(x); }
      if let Some(x) = args.loc { builder.add_loc(x); }
      builder.finish()
    }

    pub const VT_LOC: flatbuffers::VOffsetT = 4;
    pub const VT_SCALE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn loc(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(LogNormal::VT_LOC, None)
  }
  #[inline]
  pub fn scale(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(LogNormal::VT_SCALE, None)
  }
}

impl flatbuffers::Verifiable for LogNormal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"loc", Self::VT_LOC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"scale", Self::VT_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct LogNormalArgs<'a> {
    pub loc: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub scale: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for LogNormalArgs<'a> {
    #[inline]
    fn default() -> Self {
        LogNormalArgs {
            loc: None,
            scale: None,
        }
    }
}
pub struct LogNormalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogNormalBuilder<'a, 'b> {
  #[inline]
  pub fn add_loc(&mut self, loc: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(LogNormal::VT_LOC, loc);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(LogNormal::VT_SCALE, scale);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogNormalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogNormalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogNormal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for LogNormal<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("LogNormal");
      ds.field("loc", &self.loc());
      ds.field("scale", &self.scale());
      ds.finish()
  }
}
pub enum BinomialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Binomial<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Binomial<'a> {
    type Inner = Binomial<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Binomial<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Binomial { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BinomialArgs<'args>) -> flatbuffers::WIPOffset<Binomial<'bldr>> {
      let mut builder = BinomialBuilder::new(_fbb);
      if let Some(x) = args.probs { builder.add_probs(x); }
      if let Some(x) = args.total_count { builder.add_total_count(x); }
      builder.finish()
    }

    pub const VT_TOTAL_COUNT: flatbuffers::VOffsetT = 4;
    pub const VT_PROBS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn total_count(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Binomial::VT_TOTAL_COUNT, None)
  }
  #[inline]
  pub fn probs(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Binomial::VT_PROBS, None)
  }
}

impl flatbuffers::Verifiable for Binomial<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"total_count", Self::VT_TOTAL_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"probs", Self::VT_PROBS, false)?
     .finish();
    Ok(())
  }
}
pub struct BinomialArgs<'a> {
    pub total_count: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub probs: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for BinomialArgs<'a> {
    #[inline]
    fn default() -> Self {
        BinomialArgs {
            total_count: None,
            probs: None,
        }
    }
}
pub struct BinomialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BinomialBuilder<'a, 'b> {
  #[inline]
  pub fn add_total_count(&mut self, total_count: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Binomial::VT_TOTAL_COUNT, total_count);
  }
  #[inline]
  pub fn add_probs(&mut self, probs: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Binomial::VT_PROBS, probs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinomialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BinomialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Binomial<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Binomial<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Binomial");
      ds.field("total_count", &self.total_count());
      ds.field("probs", &self.probs());
      ds.finish()
  }
}
pub enum WeibullOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Weibull<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Weibull<'a> {
    type Inner = Weibull<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self { _tab: flatbuffers::Table { buf, loc } }
    }
}

impl<'a> Weibull<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Weibull { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WeibullArgs<'args>) -> flatbuffers::WIPOffset<Weibull<'bldr>> {
      let mut builder = WeibullBuilder::new(_fbb);
      if let Some(x) = args.concentration { builder.add_concentration(x); }
      if let Some(x) = args.scale { builder.add_scale(x); }
      builder.finish()
    }

    pub const VT_SCALE: flatbuffers::VOffsetT = 4;
    pub const VT_CONCENTRATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn scale(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Weibull::VT_SCALE, None)
  }
  #[inline]
  pub fn concentration(&self) -> Option<Tensor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Tensor>>(Weibull::VT_CONCENTRATION, None)
  }
}

impl flatbuffers::Verifiable for Weibull<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"scale", Self::VT_SCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Tensor>>(&"concentration", Self::VT_CONCENTRATION, false)?
     .finish();
    Ok(())
  }
}
pub struct WeibullArgs<'a> {
    pub scale: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
    pub concentration: Option<flatbuffers::WIPOffset<Tensor<'a>>>,
}
impl<'a> Default for WeibullArgs<'a> {
    #[inline]
    fn default() -> Self {
        WeibullArgs {
            scale: None,
            concentration: None,
        }
    }
}
pub struct WeibullBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WeibullBuilder<'a, 'b> {
  #[inline]
  pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Weibull::VT_SCALE, scale);
  }
  #[inline]
  pub fn add_concentration(&mut self, concentration: flatbuffers::WIPOffset<Tensor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Tensor>>(Weibull::VT_CONCENTRATION, concentration);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WeibullBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WeibullBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Weibull<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Weibull<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Weibull");
      ds.field("scale", &self.scale());
      ds.field("concentration", &self.concentration());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::root_unchecked::<Message<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Message<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
pub const MESSAGE_IDENTIFIER: &str = "PPXF";

#[inline]
pub fn message_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MESSAGE_IDENTIFIER, false)
}

#[inline]
pub fn message_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MESSAGE_IDENTIFIER, true)
}

#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, Some(MESSAGE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, Some(MESSAGE_IDENTIFIER));
}
}  // pub mod ppx

