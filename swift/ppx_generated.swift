// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum ppx_MessageBody: UInt8, Enum {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case handshake = 1
  case handshakeresult = 2
  case run = 3
  case runresult = 4
  case sample = 5
  case sampleresult = 6
  case observe = 7
  case observeresult = 8
  case tag = 9
  case tagresult = 10
  case reset = 11
  

  public static var max: ppx_MessageBody { return .reset }
  public static var min: ppx_MessageBody { return .none_ }
}

public enum ppx_Distribution: UInt8, Enum {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case normal = 1
  case uniform = 2
  case categorical = 3
  case poisson = 4
  case bernoulli = 5
  case beta = 6
  case exponential = 7
  case gamma = 8
  case lognormal = 9
  case binomial = 10
  case weibull = 11
  

  public static var max: ppx_Distribution { return .weibull }
  public static var min: ppx_Distribution { return .none_ }
}

public struct ppx_Message: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsMessage(bb: ByteBuffer) -> ppx_Message { return ppx_Message(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case bodyType = 4
    case body = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var bodyType: ppx_MessageBody { let o = _accessor.offset(VTOFFSET.bodyType.v); return o == 0 ? .none_ : ppx_MessageBody(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func body<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.body.v); return o == 0 ? nil : _accessor.union(o) }
  public static func startMessage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(bodyType: ppx_MessageBody, _ fbb: inout FlatBufferBuilder) { fbb.add(element: bodyType.rawValue, def: 0, at: VTOFFSET.bodyType.p) }
  public static func add(body: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: body, at: VTOFFSET.body.p) }
  public static func endMessage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMessage(
    _ fbb: inout FlatBufferBuilder,
    bodyType: ppx_MessageBody = .none_,
    bodyOffset body: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Message.startMessage(&fbb)
    ppx_Message.add(bodyType: bodyType, &fbb)
    ppx_Message.add(body: body, &fbb)
    return ppx_Message.endMessage(&fbb, start: __start)
  }
}

public struct ppx_Tensor: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsTensor(bb: ByteBuffer) -> ppx_Tensor { return ppx_Tensor(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case data = 4
    case shape = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var dataCount: Int32 { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func data(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.data.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var data: [Double] { return _accessor.getVector(at: VTOFFSET.data.v) ?? [] }
  public var shapeCount: Int32 { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func shape(at index: Int32) -> Int32 { let o = _accessor.offset(VTOFFSET.shape.v); return o == 0 ? 0 : _accessor.directRead(of: Int32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var shape: [Int32] { return _accessor.getVector(at: VTOFFSET.shape.v) ?? [] }
  public static func startTensor(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  public static func addVectorOf(shape: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shape, at: VTOFFSET.shape.p) }
  public static func endTensor(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTensor(
    _ fbb: inout FlatBufferBuilder,
    dataVectorOffset data: Offset = Offset(),
    shapeVectorOffset shape: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Tensor.startTensor(&fbb)
    ppx_Tensor.addVectorOf(data: data, &fbb)
    ppx_Tensor.addVectorOf(shape: shape, &fbb)
    return ppx_Tensor.endTensor(&fbb, start: __start)
  }
}

public struct ppx_Handshake: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsHandshake(bb: ByteBuffer) -> ppx_Handshake { return ppx_Handshake(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case systemName = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var systemName: String? { let o = _accessor.offset(VTOFFSET.systemName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var systemNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.systemName.v) }
  public static func startHandshake(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(systemName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: systemName, at: VTOFFSET.systemName.p) }
  public static func endHandshake(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createHandshake(
    _ fbb: inout FlatBufferBuilder,
    systemNameOffset systemName: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Handshake.startHandshake(&fbb)
    ppx_Handshake.add(systemName: systemName, &fbb)
    return ppx_Handshake.endHandshake(&fbb, start: __start)
  }
}

public struct ppx_HandshakeResult: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsHandshakeResult(bb: ByteBuffer) -> ppx_HandshakeResult { return ppx_HandshakeResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case systemName = 4
    case modelName = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var systemName: String? { let o = _accessor.offset(VTOFFSET.systemName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var systemNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.systemName.v) }
  public var modelName: String? { let o = _accessor.offset(VTOFFSET.modelName.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modelNameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.modelName.v) }
  public static func startHandshakeResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(systemName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: systemName, at: VTOFFSET.systemName.p) }
  public static func add(modelName: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modelName, at: VTOFFSET.modelName.p) }
  public static func endHandshakeResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createHandshakeResult(
    _ fbb: inout FlatBufferBuilder,
    systemNameOffset systemName: Offset = Offset(),
    modelNameOffset modelName: Offset = Offset()
  ) -> Offset {
    let __start = ppx_HandshakeResult.startHandshakeResult(&fbb)
    ppx_HandshakeResult.add(systemName: systemName, &fbb)
    ppx_HandshakeResult.add(modelName: modelName, &fbb)
    return ppx_HandshakeResult.endHandshakeResult(&fbb, start: __start)
  }
}

public struct ppx_Run: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsRun(bb: ByteBuffer) -> ppx_Run { return ppx_Run(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startRun(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endRun(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
}

public struct ppx_RunResult: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsRunResult(bb: ByteBuffer) -> ppx_RunResult { return ppx_RunResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case result = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var result: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.result.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startRunResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(result: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: result, at: VTOFFSET.result.p) }
  public static func endRunResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRunResult(
    _ fbb: inout FlatBufferBuilder,
    resultOffset result: Offset = Offset()
  ) -> Offset {
    let __start = ppx_RunResult.startRunResult(&fbb)
    ppx_RunResult.add(result: result, &fbb)
    return ppx_RunResult.endRunResult(&fbb, start: __start)
  }
}

public struct ppx_Sample: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsSample(bb: ByteBuffer) -> ppx_Sample { return ppx_Sample(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case address = 4
    case name = 6
    case distributionType = 8
    case distribution = 10
    case control = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var address: String? { let o = _accessor.offset(VTOFFSET.address.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.address.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var distributionType: ppx_Distribution { let o = _accessor.offset(VTOFFSET.distributionType.v); return o == 0 ? .none_ : ppx_Distribution(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func distribution<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.distribution.v); return o == 0 ? nil : _accessor.union(o) }
  public var control: Bool { let o = _accessor.offset(VTOFFSET.control.v); return o == 0 ? true : 0 != _accessor.readBuffer(of: Byte.self, at: o) }
  public static func startSample(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(address: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: address, at: VTOFFSET.address.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(distributionType: ppx_Distribution, _ fbb: inout FlatBufferBuilder) { fbb.add(element: distributionType.rawValue, def: 0, at: VTOFFSET.distributionType.p) }
  public static func add(distribution: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: distribution, at: VTOFFSET.distribution.p) }
  public static func add(control: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: control, def: true,
   at: VTOFFSET.control.p) }
  public static func endSample(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSample(
    _ fbb: inout FlatBufferBuilder,
    addressOffset address: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    distributionType: ppx_Distribution = .none_,
    distributionOffset distribution: Offset = Offset(),
    control: Bool = true
  ) -> Offset {
    let __start = ppx_Sample.startSample(&fbb)
    ppx_Sample.add(address: address, &fbb)
    ppx_Sample.add(name: name, &fbb)
    ppx_Sample.add(distributionType: distributionType, &fbb)
    ppx_Sample.add(distribution: distribution, &fbb)
    ppx_Sample.add(control: control, &fbb)
    return ppx_Sample.endSample(&fbb, start: __start)
  }
}

public struct ppx_SampleResult: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsSampleResult(bb: ByteBuffer) -> ppx_SampleResult { return ppx_SampleResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case result = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var result: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.result.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startSampleResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(result: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: result, at: VTOFFSET.result.p) }
  public static func endSampleResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSampleResult(
    _ fbb: inout FlatBufferBuilder,
    resultOffset result: Offset = Offset()
  ) -> Offset {
    let __start = ppx_SampleResult.startSampleResult(&fbb)
    ppx_SampleResult.add(result: result, &fbb)
    return ppx_SampleResult.endSampleResult(&fbb, start: __start)
  }
}

public struct ppx_Observe: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsObserve(bb: ByteBuffer) -> ppx_Observe { return ppx_Observe(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case address = 4
    case name = 6
    case distributionType = 8
    case distribution = 10
    case value = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var address: String? { let o = _accessor.offset(VTOFFSET.address.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.address.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var distributionType: ppx_Distribution { let o = _accessor.offset(VTOFFSET.distributionType.v); return o == 0 ? .none_ : ppx_Distribution(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func distribution<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.distribution.v); return o == 0 ? nil : _accessor.union(o) }
  public var value: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startObserve(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(address: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: address, at: VTOFFSET.address.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(distributionType: ppx_Distribution, _ fbb: inout FlatBufferBuilder) { fbb.add(element: distributionType.rawValue, def: 0, at: VTOFFSET.distributionType.p) }
  public static func add(distribution: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: distribution, at: VTOFFSET.distribution.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func endObserve(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createObserve(
    _ fbb: inout FlatBufferBuilder,
    addressOffset address: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    distributionType: ppx_Distribution = .none_,
    distributionOffset distribution: Offset = Offset(),
    valueOffset value: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Observe.startObserve(&fbb)
    ppx_Observe.add(address: address, &fbb)
    ppx_Observe.add(name: name, &fbb)
    ppx_Observe.add(distributionType: distributionType, &fbb)
    ppx_Observe.add(distribution: distribution, &fbb)
    ppx_Observe.add(value: value, &fbb)
    return ppx_Observe.endObserve(&fbb, start: __start)
  }
}

public struct ppx_ObserveResult: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsObserveResult(bb: ByteBuffer) -> ppx_ObserveResult { return ppx_ObserveResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startObserveResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endObserveResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
}

public struct ppx_Tag: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsTag(bb: ByteBuffer) -> ppx_Tag { return ppx_Tag(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case address = 4
    case name = 6
    case value = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var address: String? { let o = _accessor.offset(VTOFFSET.address.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var addressSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.address.v) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var value: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startTag(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(address: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: address, at: VTOFFSET.address.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func endTag(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTag(
    _ fbb: inout FlatBufferBuilder,
    addressOffset address: Offset = Offset(),
    nameOffset name: Offset = Offset(),
    valueOffset value: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Tag.startTag(&fbb)
    ppx_Tag.add(address: address, &fbb)
    ppx_Tag.add(name: name, &fbb)
    ppx_Tag.add(value: value, &fbb)
    return ppx_Tag.endTag(&fbb, start: __start)
  }
}

public struct ppx_TagResult: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsTagResult(bb: ByteBuffer) -> ppx_TagResult { return ppx_TagResult(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startTagResult(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endTagResult(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
}

public struct ppx_Reset: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsReset(bb: ByteBuffer) -> ppx_Reset { return ppx_Reset(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  public static func startReset(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 0) }
  public static func endReset(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
}

public struct ppx_Normal: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsNormal(bb: ByteBuffer) -> ppx_Normal { return ppx_Normal(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case mean = 4
    case stddev = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var mean: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.mean.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var stddev: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.stddev.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startNormal(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(mean: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: mean, at: VTOFFSET.mean.p) }
  public static func add(stddev: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: stddev, at: VTOFFSET.stddev.p) }
  public static func endNormal(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createNormal(
    _ fbb: inout FlatBufferBuilder,
    meanOffset mean: Offset = Offset(),
    stddevOffset stddev: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Normal.startNormal(&fbb)
    ppx_Normal.add(mean: mean, &fbb)
    ppx_Normal.add(stddev: stddev, &fbb)
    return ppx_Normal.endNormal(&fbb, start: __start)
  }
}

public struct ppx_Uniform: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsUniform(bb: ByteBuffer) -> ppx_Uniform { return ppx_Uniform(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case low = 4
    case high = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var low: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.low.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var high: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.high.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startUniform(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(low: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: low, at: VTOFFSET.low.p) }
  public static func add(high: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: high, at: VTOFFSET.high.p) }
  public static func endUniform(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUniform(
    _ fbb: inout FlatBufferBuilder,
    lowOffset low: Offset = Offset(),
    highOffset high: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Uniform.startUniform(&fbb)
    ppx_Uniform.add(low: low, &fbb)
    ppx_Uniform.add(high: high, &fbb)
    return ppx_Uniform.endUniform(&fbb, start: __start)
  }
}

public struct ppx_Categorical: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsCategorical(bb: ByteBuffer) -> ppx_Categorical { return ppx_Categorical(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case probs = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var probs: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.probs.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCategorical(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(probs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: probs, at: VTOFFSET.probs.p) }
  public static func endCategorical(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCategorical(
    _ fbb: inout FlatBufferBuilder,
    probsOffset probs: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Categorical.startCategorical(&fbb)
    ppx_Categorical.add(probs: probs, &fbb)
    return ppx_Categorical.endCategorical(&fbb, start: __start)
  }
}

public struct ppx_Poisson: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsPoisson(bb: ByteBuffer) -> ppx_Poisson { return ppx_Poisson(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case rate = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var rate: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.rate.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startPoisson(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(rate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rate, at: VTOFFSET.rate.p) }
  public static func endPoisson(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPoisson(
    _ fbb: inout FlatBufferBuilder,
    rateOffset rate: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Poisson.startPoisson(&fbb)
    ppx_Poisson.add(rate: rate, &fbb)
    return ppx_Poisson.endPoisson(&fbb, start: __start)
  }
}

public struct ppx_Bernoulli: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsBernoulli(bb: ByteBuffer) -> ppx_Bernoulli { return ppx_Bernoulli(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case probs = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var probs: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.probs.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startBernoulli(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(probs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: probs, at: VTOFFSET.probs.p) }
  public static func endBernoulli(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBernoulli(
    _ fbb: inout FlatBufferBuilder,
    probsOffset probs: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Bernoulli.startBernoulli(&fbb)
    ppx_Bernoulli.add(probs: probs, &fbb)
    return ppx_Bernoulli.endBernoulli(&fbb, start: __start)
  }
}

public struct ppx_Beta: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsBeta(bb: ByteBuffer) -> ppx_Beta { return ppx_Beta(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case concentration1 = 4
    case concentration0 = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var concentration1: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.concentration1.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var concentration0: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.concentration0.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startBeta(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(concentration1: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: concentration1, at: VTOFFSET.concentration1.p) }
  public static func add(concentration0: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: concentration0, at: VTOFFSET.concentration0.p) }
  public static func endBeta(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBeta(
    _ fbb: inout FlatBufferBuilder,
    concentration1Offset concentration1: Offset = Offset(),
    concentration0Offset concentration0: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Beta.startBeta(&fbb)
    ppx_Beta.add(concentration1: concentration1, &fbb)
    ppx_Beta.add(concentration0: concentration0, &fbb)
    return ppx_Beta.endBeta(&fbb, start: __start)
  }
}

public struct ppx_Exponential: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsExponential(bb: ByteBuffer) -> ppx_Exponential { return ppx_Exponential(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case rate = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var rate: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.rate.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startExponential(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(rate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rate, at: VTOFFSET.rate.p) }
  public static func endExponential(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createExponential(
    _ fbb: inout FlatBufferBuilder,
    rateOffset rate: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Exponential.startExponential(&fbb)
    ppx_Exponential.add(rate: rate, &fbb)
    return ppx_Exponential.endExponential(&fbb, start: __start)
  }
}

public struct ppx_Gamma: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsGamma(bb: ByteBuffer) -> ppx_Gamma { return ppx_Gamma(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case concentration = 4
    case rate = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var concentration: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.concentration.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var rate: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.rate.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startGamma(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(concentration: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: concentration, at: VTOFFSET.concentration.p) }
  public static func add(rate: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rate, at: VTOFFSET.rate.p) }
  public static func endGamma(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGamma(
    _ fbb: inout FlatBufferBuilder,
    concentrationOffset concentration: Offset = Offset(),
    rateOffset rate: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Gamma.startGamma(&fbb)
    ppx_Gamma.add(concentration: concentration, &fbb)
    ppx_Gamma.add(rate: rate, &fbb)
    return ppx_Gamma.endGamma(&fbb, start: __start)
  }
}

public struct ppx_LogNormal: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsLogNormal(bb: ByteBuffer) -> ppx_LogNormal { return ppx_LogNormal(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case loc = 4
    case scale = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var loc: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.loc.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var scale: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startLogNormal(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(loc: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: loc, at: VTOFFSET.loc.p) }
  public static func add(scale: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scale, at: VTOFFSET.scale.p) }
  public static func endLogNormal(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLogNormal(
    _ fbb: inout FlatBufferBuilder,
    locOffset loc: Offset = Offset(),
    scaleOffset scale: Offset = Offset()
  ) -> Offset {
    let __start = ppx_LogNormal.startLogNormal(&fbb)
    ppx_LogNormal.add(loc: loc, &fbb)
    ppx_LogNormal.add(scale: scale, &fbb)
    return ppx_LogNormal.endLogNormal(&fbb, start: __start)
  }
}

public struct ppx_Binomial: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsBinomial(bb: ByteBuffer) -> ppx_Binomial { return ppx_Binomial(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case totalCount = 4
    case probs = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var totalCount: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.totalCount.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var probs: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.probs.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startBinomial(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(totalCount: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: totalCount, at: VTOFFSET.totalCount.p) }
  public static func add(probs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: probs, at: VTOFFSET.probs.p) }
  public static func endBinomial(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBinomial(
    _ fbb: inout FlatBufferBuilder,
    totalCountOffset totalCount: Offset = Offset(),
    probsOffset probs: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Binomial.startBinomial(&fbb)
    ppx_Binomial.add(totalCount: totalCount, &fbb)
    ppx_Binomial.add(probs: probs, &fbb)
    return ppx_Binomial.endBinomial(&fbb, start: __start)
  }
}

public struct ppx_Weibull: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: "PPXF", addPrefix: prefix) }
  public static func getRootAsWeibull(bb: ByteBuffer) -> ppx_Weibull { return ppx_Weibull(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case scale = 4
    case concentration = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var scale: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.scale.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var concentration: ppx_Tensor? { let o = _accessor.offset(VTOFFSET.concentration.v); return o == 0 ? nil : ppx_Tensor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startWeibull(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(scale: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: scale, at: VTOFFSET.scale.p) }
  public static func add(concentration: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: concentration, at: VTOFFSET.concentration.p) }
  public static func endWeibull(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createWeibull(
    _ fbb: inout FlatBufferBuilder,
    scaleOffset scale: Offset = Offset(),
    concentrationOffset concentration: Offset = Offset()
  ) -> Offset {
    let __start = ppx_Weibull.startWeibull(&fbb)
    ppx_Weibull.add(scale: scale, &fbb)
    ppx_Weibull.add(concentration: concentration, &fbb)
    return ppx_Weibull.endWeibull(&fbb, start: __start)
  }
}

